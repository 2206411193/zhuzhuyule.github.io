{"meta":{"title":"猪猪娱乐","subtitle":"做自己爱做的事，爱自己在做的事！","description":"每个人都可以活的很有价值！","author":"zhuzhuxia","url":"https://zhuzhuyule.com"},"pages":[{"title":"关于博主","date":"2017-01-12T12:56:16.000Z","updated":"2017-11-14T12:27:25.315Z","comments":true,"path":"about/index.html","permalink":"https://zhuzhuyule.com/about/index.html","excerpt":"","text":"姓名 猪猪侠 归属地 地球の上海 工作 一枚程序猿 我要饭の账号 支付宝 微信"},{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2017-11-14T12:27:25.905Z","comments":false,"path":"categories/index.html","permalink":"https://zhuzhuyule.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2017-11-14T12:27:26.265Z","comments":false,"path":"tags/index.html","permalink":"https://zhuzhuyule.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"优化Node下Log4js输出格式","slug":"Experiences/优化Node下Log4js输出格式","date":"2018-01-31T02:11:40.000Z","updated":"2018-02-06T08:30:27.204Z","comments":true,"path":"blog/Experiences/优化Node下Log4js输出格式.html","link":"","permalink":"https://zhuzhuyule.com/blog/Experiences/优化Node下Log4js输出格式.html","excerpt":"修改前.\\node_modules\\log4js\\lib\\layouts_new.js1234567891011function timestampLevelAndCategory(loggingEvent, colour, timezoneOffset) &#123; return colorize( formatLogData( '[%s] [%s] %s - ' , dateFormat.asString(loggingEvent.startTime, timezoneOffset) , loggingEvent.level , loggingEvent.categoryName ) , colour );&#125; 输出样式：","text":"修改前.\\node_modules\\log4js\\lib\\layouts_new.js1234567891011function timestampLevelAndCategory(loggingEvent, colour, timezoneOffset) &#123; return colorize( formatLogData( '[%s] [%s] %s - ' , dateFormat.asString(loggingEvent.startTime, timezoneOffset) , loggingEvent.level , loggingEvent.categoryName ) , colour );&#125; 输出样式： 修改后.\\node_modules\\log4js\\lib\\layouts_new.js1234567891011function timestampLevelAndCategory(loggingEvent, colour, timezoneOffset) &#123; return colorize( formatLogData( '[%s] [%s] %s | ' , dateFormat.asString(loggingEvent.startTime, timezoneOffset) , (loggingEvent.level+' ').slice(0,5) , loggingEvent.categoryName ) , colour );&#125; 输出样式：","categories":[{"name":"Front","slug":"Front","permalink":"https://zhuzhuyule.com/categories/Front/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://zhuzhuyule.com/tags/Node/"}]},{"title":"纯CSS实现轮播图","slug":"Front/纯CSS实现轮播图","date":"2017-11-16T07:17:33.000Z","updated":"2017-11-17T12:56:18.152Z","comments":true,"path":"blog/Front/纯CSS实现轮播图.html","link":"","permalink":"https://zhuzhuyule.com/blog/Front/纯CSS实现轮播图.html","excerpt":"实现轮播图，如下效果： .wheelPlayer{ padding: 20px 0; margin: auto; width: 350px; } .wheelPlayer div{ position: relative; height: 25px; line-height: 26px; width: 70px; text-align: center; border: 1px solid gray; } .wheelAnimate div{ animation: whellPlayer 9s infinite; -moz-animation: whellPlayer 9s infinite; -webkit-animation: whellPlayer 9s infinite; } .wheelPlayer div:nth-of-type(1){ animation-delay: -6s; -moz-animation-delay: -6s; -webkit-animation-delay: -6s; } .wheelPlayer div:nth-of-type(2){ animation-delay: -3s; -moz-animation-delay: -3s; -webkit-animation-delay: -3s; margin-top: -27px; } .wheelPlayer div:nth-of-type(3){ animation-delay: -0s; -moz-animation-delay: 0s; -webkit-animation-delay: 0s; margin-top: -27px; } @keyframes whellPlayer { 1%,100%{ left: 0px; opacity: 1; } 5%,7% { opacity: 0 } 11%,33% { left: 200px; opacity: 1; } 44%,66% { left: 100px; } 77% { left: 0px; } } 1 2 3","text":"实现轮播图，如下效果： .wheelPlayer{ padding: 20px 0; margin: auto; width: 350px; } .wheelPlayer div{ position: relative; height: 25px; line-height: 26px; width: 70px; text-align: center; border: 1px solid gray; } .wheelAnimate div{ animation: whellPlayer 9s infinite; -moz-animation: whellPlayer 9s infinite; -webkit-animation: whellPlayer 9s infinite; } .wheelPlayer div:nth-of-type(1){ animation-delay: -6s; -moz-animation-delay: -6s; -webkit-animation-delay: -6s; } .wheelPlayer div:nth-of-type(2){ animation-delay: -3s; -moz-animation-delay: -3s; -webkit-animation-delay: -3s; margin-top: -27px; } .wheelPlayer div:nth-of-type(3){ animation-delay: -0s; -moz-animation-delay: 0s; -webkit-animation-delay: 0s; margin-top: -27px; } @keyframes whellPlayer { 1%,100%{ left: 0px; opacity: 1; } 5%,7% { opacity: 0 } 11%,33% { left: 200px; opacity: 1; } 44%,66% { left: 100px; } 77% { left: 0px; } } 1 2 3 代码展示这里涉及到css3中的 动画效果 animate 和 @keyframes 先贴一下代码：wheelPlayer.html12345&lt;div class=\"wheelPlayer wheelAnimate\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;&lt;/div&gt; CSS 样式配置：wheelPlayer.css1234567891011121314151617181920212223242526272829303132333435363738.wheelPlayer&#123; padding: 20px 0; margin: auto; width: 350px;&#125;.wheelPlayer div&#123; position: relative; height: 25px; line-height: 26px; width: 70px; text-align: center; border: 1px solid gray;&#125;.wheelAnimate div&#123; animation: whellPlayer 9s infinite; -moz-animation: whellPlayer 9s infinite; -webkit-animation: whellPlayer 9s infinite;&#125;.wheelPlayer div:nth-of-type(1)&#123; animation-delay: -6s; -moz-animation-delay: -6s; -webkit-animation-delay: -6s;&#125;.wheelPlayer div:nth-of-type(2)&#123; animation-delay: -3s; -moz-animation-delay: -3s; -webkit-animation-delay: -3s; margin-top: -27px;&#125;.wheelPlayer div:nth-of-type(3)&#123; animation-delay: -0s; -moz-animation-delay: 0s; -webkit-animation-delay: 0s; margin-top: -27px;&#125; 动画实现思路 .flexContiner{ display: flex; flex-wrap: wrap; justify-content: flex-start; align-items: center; position: relative; } .tempPadding{ padding: 30px 0; } #wheelArea, #wheelBox { margin: auto; width: 350px; } #wheelArea { padding: 10px; color: black; } #wheelArea div, #wheelBox div{ float: left; height: 25px; line-height: 26px; width: 70px; text-align: center; border: 1px solid gray; margin-left: 20px; } #wheelArea div{ border-color: rgba(0,0,0,0); } 1 2 3 A B C 单个模块动画过程分析以分析 1 模块的移动过程，2 3的移动过程是相同的，只是他们出发动画的时间不同就可以了。 初始化位置 1% 以及100% :将 1 的初始/重置位置设置到 A 的位置 动画整体流程 1% ~ 33% 将 1 从 A 移动 到 C 的位置 33% ~ 66% 将 1 从 C 移动 到 B 的位置 66% ~ 100% 将 1 从 B 移动 到 A 的位置 拆解过程 将1 从 X 移动到 Y 位置的过程 使用前 11% 的时间去做移动的操作 1% ~ 11% :将 1 从 A 移动 到 C 的位置 33% ~ 44% :将 1 从 C 移动 到 B 的位置 66% ~ 77% :将 1 从 B 移动 到 A 的位置 使用后 22% 的时间做保持动画停顿的操作 11% ~ 33% :保持 1 在 C 的位置 44% ~ 66% :保持 1 在 B 的位置 77% ~ 100%:保持 1 在 A 的位置 拆解过程 将1 从 A 移动到 C 位置的过程中移动 (只有这个状态比较特殊，需增加渐变显示的效果) 只需要在1% ~ 11%这个移动操作中添加效果 1% ~ 5% :将 1 透明度 从 1降低到0 5% ~ 7% :将 1 保持 透明度为0 7% ~ 11% :将 1 透明度 从 0还原到1 整体运用动画实现效果动画的执行过程就解析完毕了，那么怎么让三块内容依次执行呢？这里只需要来让他们开始执行的时间错开就可以了。123456789.wheelPlayer div:nth-of-type(1)&#123; animation-delay: 0s;&#125;.wheelPlayer div:nth-of-type(2)&#123; animation-delay: 3s;&#125;.wheelPlayer div:nth-of-type(3)&#123; animation-delay: 6s;&#125; .eg1 div:first-of-type{ animation-delay: 0s; -moz-animation-delay: 0s; -webkit-animation-delay: 0s; } .eg1 div:nth-of-type(2){ animation-delay: 3s; -moz-animation-delay: 3s; -webkit-animation-delay: 3s; } .eg1 div:last-of-type{ animation-delay: 6s; -moz-animation-delay: 6s; -webkit-animation-delay: 6s; } .startbtn{ flex: none; width: 58px; height: 20px; line-height: 20px; text-align: center; border-radius: 5px; background: gainsboro; cursor: pointer; } .floatPoint::after{ position: absolute; content:\"\\f25a\"; left: 25px; top: 75px; animation: floatpoint 1s infinite; font-family: FontAwesome !important; } @keyframes floatpoint{ 1% ,100% { top: 75px; } 50% { top: 80px; } } 启动 1 2 3 var btn = document.getElementById(\"startEg1\"); btn.onclick = function(){ var content = this.innerText; var wheelBox = document.getElementById(\"wheelBoxEg1\"); if(content == \"启动\"){ this.innerText = \"重置\"; this.classList.remove(\"floatPoint\"); wheelBox.classList.add(\"wheelAnimate\"); }else{ this.innerText = \"启动\"; this.classList.add(\"floatPoint\"); wheelBox.classList.remove(\"wheelAnimate\"); } }; 但是这不是我们需要的效果！ 升级效果我们需要一载入就看到动起来的三张图，这时候只需要将延时值设置为负数，就可以了。也就是说，在我们还没有载入页面的时候，就需要动画动起来了，我们载入页面以后，1已经执行 6s了，2已经执行3s了，而3才刚刚开始要动起来。123456789.eg2 div:nth-of-type(1)&#123; animation-delay: -6s;&#125;.eg2 div:nth-of-type(2)&#123; animation-delay: -3s;&#125;.eg2 div:nth-of-type(3)&#123; animation-delay: 0s;&#125; 启动 1 2 3 var btn = document.getElementById(\"startEg2\"); btn.onclick = function(){ this.classList.remove(\"floatPoint\"); var content = this.innerText; var wheelBox = document.getElementById(\"wheelBoxEg2\"); if(content == \"启动\"){ this.classList.remove(\"floatPoint\"); this.innerText = \"重置\"; wheelBox.classList.add(\"wheelAnimate\"); }else{ this.innerText = \"启动\"; this.classList.add(\"floatPoint\"); wheelBox.classList.remove(\"wheelAnimate\"); } };","categories":[{"name":"前端","slug":"前端","permalink":"https://zhuzhuyule.com/categories/前端/"}],"tags":[{"name":"轮播图","slug":"轮播图","permalink":"https://zhuzhuyule.com/tags/轮播图/"},{"name":"CSS","slug":"CSS","permalink":"https://zhuzhuyule.com/tags/CSS/"}]},{"title":"JS封装（上）","slug":"Front/JS封装（上）","date":"2017-11-16T07:17:33.000Z","updated":"2018-02-06T08:56:15.409Z","comments":true,"path":"blog/Front/JS封装（上）.html","link":"","permalink":"https://zhuzhuyule.com/blog/Front/JS封装（上）.html","excerpt":"JavaScript 中类的特性： 构造函数 静态属性，静态方法 共有属性，共有方法 私有属性，私有方法","text":"JavaScript 中类的特性： 构造函数 静态属性，静态方法 共有属性，共有方法 私有属性，私有方法 一个简单的类//Person():构造函数, Person：类var Person = function(name, age)&#123; //共有属性 this.name = name; this.age = age; //共有方法 this.sayName = function()&#123; console.log(this.name); &#125;; 当对象被实例化后，构造函数会立即执行它所包含的任何代码使用方式：var p1 = new Person('zhuzhuxia',2);var p2 = Person('zhuzhuxia',2); //注意这里少了 newconsole.log(p1) //&#123;name: \"zhuzhuxia\", age: 2, sayName: function&#125;console.log(window.name); //undefinedconsole.log(window.age); //undefinedconsole.log(p2) //undefinedconsole.log(window.name); //zhuzhuxiaconsole.log(window.age); //2 Tip:这里要说明下，使用 new 关键字，JavaScript会识别为对象，将 this 指向类的实例中，但是如果没有使用 new 关键字，this 将会指向全局变量 window，及 this.name = &quot;zhuzhuxia&quot; 等价于 window.name = &quot;zhuzhuxia&quot;，因此 p2 是个无效值！ 解决方案：var Person = function(name, age)&#123; if (this instanceof Person)&#123; //共有属性 this.name = name; this.age = age; //共有方法 this.sayName = function()&#123; console.log(this.name); &#125;; &#125; else &#123; return new Person(name, age); &#125; &#125; 效果：var p1 = new Person('zhuzhuxia',2);var p2 = Person('zhuzhuxia',2); //注意这里少了 newconsole.log(p1) //&#123;name: \"zhuzhuxia\", age: 2, sayName: function&#125;console.log(window.name); //undefinedconsole.log(window.age); //undefinedconsole.log(p1) //&#123;name: \"zhuzhuxia\", age: 2, sayName: function&#125;console.log(window.name); //undefinedconsole.log(window.age); //undefined 一个复杂的类有了上面的例子之后，我们在此基础之上就可以进行我们的完善了。 //全部在构造函数中创建的成员(注：只是以下形式定义的成员)，将会在每个实例中生成同名的成员副本//因而实例越多占用的内存越多function Person(name, age) &#123; //私有属性,不能被外部公开访问 var defname = 'zhuzhuxia'; //私有方法,不能被外部公开访问 var sayName = function () &#123; console.log(this.name); &#125; function sayAge() &#123; console.log(this.age); &#125; //公有属性,可以被外部公开访问,且通过 实例 调用 this.name = name; this.age = age; this.address = '中国'; //公有方法,可以被外部公开访问,且通过 实例 调用 this.say = function () &#123; this.sayHello(defname); //在公有方法中可以访问私有成员和 prototype中的成员 &#125;&#125;//公有属性,可以被外部公开访问,且通过 实例 调用//区别：prototype中添加成员,只有一份，与实例个数无关Person.prototype.sayHello = function (name) &#123; if (name == undefined) console.log('Hello ' + this.name); //访问实例中的公有属性 else console.log('Hello ' + name);&#125;//静态属性,可以被外部公开访问,但只能通过 构造函数 来调用Person.classname = '人';//静态方法,可以被外部公开访问,但只能通过 构造函数 来调用Person.showclass = function () &#123; console.log(this.classname);&#125; 实例化后使用：//实例化var p = new Person('test');/*---- 测试prototype ----*/console.log(p.prototype); //undefined 实例对象没有prototypeconsole.log(Person.prototype); //&#123;sayHello: ƒ, constructor: ƒ&#125;console.log(Person.prototype.constructor); //Person(name,age)&#123;...&#125; 构造函数整体，可以换做 alert来输出console.log(Person.prototype.constructor.classname); //china 相当于myObject.name;/*---- 测试属性 ----*/console.log(Person.address); //undefined Person中的this指的不是函数本身，而是调用address的对象，而且只能是对象console.log(Person.classname); //人console.log(p.address); //中国 此时this指的是实例化后的p，及p是调用address的对象console.log(p.classname); //undefined 静态属性不适用于一般实例console.log(p.constructor.classname); //人 想访问类的静态属性，先访问该实例的构造函数，然后在访问该类静态属性/*---- 测试方法 ----*/Person.showclass(); //人 直接调用 构造函数（类）的静态方法p.say(); //Hello zhuzhuxia Person类中的方法将会被实例继承p.sayHello(); //Hello test Person类的prototype原型下的方法将会被实例继承p.constructor.showclass();//人 调用该对象构造函数（类函数）的方法（函数）/*-- 错误的方法调用 --*///sayHello是原型方法，不是类的方法//Person.sayHello(); //Uncaught TypeError: Person.sayHello is not a function//showclass是Person类的方法，和实例对象没有直接关系//p.showclass(); //Uncaught TypeError: p.showclass is not a function 封装js类这里我们用闭包来实现，首先解释下闭包的概念。闭包概念：一个函数有权访问另一个函数作用域中的变量，即在一个函数内部创建另一个函数 实现如下：var Person = (function()&#123; //静态私有属性方法 var home = \"China\"; function sayHome(name)&#123; console.log(name + \"'s home in \" + home); &#125; //构造函数 function _person(name, age)&#123; var _this = this; //构造函数安全模式，避免创建时候丢掉new关键字 if(_this instanceof _person)&#123; //共有属性, 方法 _this.name = name; _this.getHome = function()&#123; //内部访问私有属性，方法 sayHome(_this.name); &#125;; _this.test = sayHome; //用于测试 //构造器 _this.setAge = function(age)&#123; _this.age = age + 12; &#125;(age); &#125;else&#123; return new _person(name, age); &#125; &#125; //静态共有属性方法 _person.prototype = &#123; constructor: _person, drink: \"water\", sayWord: function()&#123; console.log(\"ys is a boy\"); &#125; &#125; return _person;&#125;)(); 调用如下：var p1 = new Person(\"ys\", 12);p1.getHome(); //ys's home in Chinaconsole.log(p1.age); //24var p2 = Person(\"ys\", 12);p2.getHome(); //ys's home in Chinaconsole.log(p2.age); //24console.log(p2.test == p1.test); //true, 证明静态私有变量共享性 总结 有些公共属性，方法，可以设置为静态的，这样可以在每次实例化的时候，不需要额外开辟内存资源，达到真正意义上的共享， 有些公共的属性方法，只想在内部程序处理时候达到共享，则设置为，静态私有属性方法， 有些公共的属性方法，想在实例对象中达到共享，则设置为prototype属性方法 相关参考 js如何创建类（封装）","categories":[{"name":"前端","slug":"前端","permalink":"https://zhuzhuyule.com/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://zhuzhuyule.com/tags/JS/"},{"name":"面向对象","slug":"面向对象","permalink":"https://zhuzhuyule.com/tags/面向对象/"}]},{"title":"HEXO下的语法高亮拓展修改","slug":"HEXO/HEXO下的语法高亮拓展修改","date":"2017-09-09T06:33:21.000Z","updated":"2018-02-06T08:56:09.024Z","comments":true,"path":"blog/HEXO/HEXO下的语法高亮拓展修改.html","link":"","permalink":"https://zhuzhuyule.com/blog/HEXO/HEXO下的语法高亮拓展修改.html","excerpt":"本文主要记录一下，修改Hexo下语法高亮的各种用法，修改后的语法可以快速设置多种样式，主要功能如下： 设置语法语言 设置标题 是否显示行号 设置起始行号 选定行号标记 设置代码添加删除标记 （2017年11月26日新增） 设置跳转超级链接","text":"本文主要记录一下，修改Hexo下语法高亮的各种用法，修改后的语法可以快速设置多种样式，主要功能如下： 设置语法语言 设置标题 是否显示行号 设置起始行号 选定行号标记 设置代码添加删除标记 （2017年11月26日新增） 设置跳转超级链接 格式总览主要功能如上，都是自带功能，更重要的是只是想在``` ``` 后直接实现设置，不想使用{ % ... % }去实现这些功能。 格式 ```[language] [:title] [lang:language] [line_number:(true|false)] [first_line:number] [mark:#,#-#] [diff:true|false] [url:http...]code snippet``` 自定义 ```code snippet``` 效果 function getRegExcData(Content){ var rBacktick = /(\\s*)(`{3,}|~{3,}) *(.*) *\\n([\\s\\S]+?)\\s*\\2(\\n|$)/g; var rUrl = /\\s+url:(https?:\\/\\/\\S+)(?:\\s+(\\S+))?\\s*/i; var rLang = /(?:^|lang:)\\s*(\\w+)[\\$\\s]/i; var rLineNumber = /\\s*line_number:(\\w+)/i; var rDiff = /\\s*diff:(\\w+)/i; var rFirstLine = /\\s*first_line:(\\d+)/i; var rMark = /\\s*mark:([0-9,\\-]+)/i; var rDirCaption = /\\s:((?:.(?!\\s\\b\\w+:))*(?:\\w+\\.)*(?:.(?!\\s\\b\\w+:))*(?:\\w+\\.)*[\\\\\\/])?([^\\\\\\/]+?)(?:(\\.[^\\.\\s]+)\\b)?\\s*(?=\\s\\b\\w+:|$)/i; var args = ' ' + Content + ' '; // 完全修改 为 tag模式 var caption = ''; var lang = ''; var line_number = 'true'; var rdiff = false; var first_line = 1; var mark = []; var match; if (rLineNumber.test(args)) { args = args.replace(rLineNumber, function() { line_number = arguments[1] === 'true'; return ' '; }); } if (rFirstLine.test(args)) { args = args.replace(rFirstLine, function() { first_line = arguments[1]; return ' '; }); } if (rDiff.test(args)) { args = args.replace(rDiff, function() { rdiff = arguments[1] === 'true'; return ' '; }); } if (rMark.test(args)) { args = args.replace(rMark, function() { mark = arguments[1].split(',').reduce(function getMarkedLines(prev, cur) { var a, b, temp; if (/\\-/.test(cur)) { a = Number(cur.substr(0, cur.indexOf('-'))); b = Number(cur.substr(cur.indexOf('-') + 1)); if (b < a) { // switch a & b temp = a; a = b; b = temp; } for (; a maxLine ? mark[i] : maxLine; } for (var i = 0, len = maxLine; i < len; i++) { numbers += '' + (firstLine + i) + ''; if ( 0 == i){ content = '' + (options.lang ? 'language:' + options.lang: 'not find language !') + ''; } else { content += '' + (i+1) + ''; } } if (caption) { result += '' + caption + ''; } //新样式 result += ''; if (gutter) { result += '' + numbers + ''; } result += '' + content + ''; result += ''; return result; } function changeEventHandler(value){ var options=getRegExcData(value); var codeArea = document.getElementById('codeArea'); codeArea.innerHTML = getCodeContent(options); } var myinput=document.getElementById('input'); document.getElementById('input').parentElement.style = \"display:flex\"; myinput.onchange(myinput.value); 使用方法设置语法语言 格式 ``` language //注意 语言类型 需要写在其他定义之前code snippet``` 样例 ```javapublic Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl(&quot;Hello World&quot;); &#125;&#125;``` 效果 12345public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl(\"Hello World\"); &#125;&#125; 设置标题 格式 ``` [:words|:path|:url|:ftp|:ip/path] //以英文冒号开头即可code snippet ``` 样例 ``` :file:///D:/zhuzhu xia/HelloWorldClass.java //如果没有定义语言，词后缀可辅助public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl(\"Hello World\"); &#125;&#125;``` 效果 file:///D:/zhuzhu xia/HelloWorldClass.java12345public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl(&quot;Hello World&quot;); &#125;&#125; 是否显示行号 格式 ``` [line_number:(true|false)] //默认truecode snippet``` 样例 ```java line_number:false public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl(\"Hello World\"); &#125;&#125;``` 效果 public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl(\"Hello World\"); &#125;&#125; 设置起始行号 格式 123``` [first_line:number] //默认code snippet``` 样例 ```java first_line:22 public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl(\"Hello World\"); &#125;&#125;``` 效果 2223242526public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl(\"Hello World\"); &#125;&#125; 选定行号标记 格式 ``` [mark:#,#-#] //#行号，#-#行号范围code snippet``` 样例 ```java mark:2,4,8,10-14,18 public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); &#125;&#125;``` 效果 1234567891011121314151617181920public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); System.Out.printl(\"Hello World\"); &#125;&#125; 设置代码添加删除标记 格式 ``` [diff:true|false] code snippet``` 样例 ```js diff:true 'use struct';-var name = 'zhu'+var name = 'zhuzhuxia';function sayHello()&#123;- alert(name);+ console.log(name);&#125;``` 效果 123456789'use struct';var name = 'zhu'var name = 'zhuzhuxia';function sayHello()&#123; alert(name); console.log(name);&#125; 还有更惊喜的功能，你点击左上角 复制 按钮，粘贴出去试试看！只会复制出最新代码哦。 设置跳转超级链接 格式 ``` [url:http... download|下载] //url:http 开头，无download则跳转链接，有则下载内容code snippet``` 样例 ``` :需要标题 url:https://zhuzhuyule.com/images/avatar.png download这里会下载我的头像！``` 效果 需要标题 download1这里会下载我的头像！ 修改代码如果需要实现以上功能，需要更改 ./node_modules/目录下插件： node_module |--hexo| |--lib| |--plugins| |--filter| |--before_post_render| |--backtick_code_block.js ||--hexo-util| |--lib| |--highlight.js 覆盖以上文件即可，详细不在这里描述了。 在添加样式文件即可： themes |--next| |--source| |--css| |--_custom| |--highlight.styl | |--custom.styl //感谢 @maoshengyang 提醒，还需要添加文件引用：@import highlight; custom.styl中添加样式文件引用：custom.styl@import highlight; theme.styl中直接添加颜色，可以自己调整颜色（放在这里好控制管理皮肤）：.\\themes\\next\\source\\css\\_common\\components\\highlight\\theme.styl$highlight-diffdeletion = #c7ffd7$highlight-diffaddition = #ffd3d8 也可以这样，这是我的 自己使用的皮肤配色：.\\themes\\next\\source\\css\\_common\\components\\highlight\\theme.stylif $highlight_theme == \"custom light\" $highlight-figcaptionBK = #eee $highlight-figcaptionFont = #777 $highlight-background = #f8f8f8 $highlight-emphasisBK = #ffffff $highlight-emphasisFont = #111 $highlight-current-line = #efefef $highlight-selection = #d6d6d6 $highlight-foreground = #4d4d4c $highlight-comment = #6eb55e $highlight-red = #c82829 $highlight-orange = #f5871f $highlight-yellow = #eab700 $highlight-green = #718c00 $highlight-aqua = #3e999f $highlight-blue = #4271ae $highlight-purple = #1212a0 $highlight-diffdeletion = #c7ffd7 $highlight-diffaddition = #ffd3d8 $highlight-gutter = &#123; color: #5c5c5c, bg-color: #e7e5dc, right-border-color: #aed581 &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://zhuzhuyule.com/categories/前端/"},{"name":"Hexo","slug":"前端/Hexo","permalink":"https://zhuzhuyule.com/categories/前端/Hexo/"}],"tags":[{"name":"Hexo优化系列","slug":"Hexo优化系列","permalink":"https://zhuzhuyule.com/tags/Hexo优化系列/"}]},{"title":"Delphi下获取网络数据乱码问题","slug":"Skill/Delphi下获取网络数据乱码问题","date":"2017-09-06T01:04:27.000Z","updated":"2017-09-07T01:25:39.600Z","comments":true,"path":"blog/Skill/Delphi下获取网络数据乱码问题.html","link":"","permalink":"https://zhuzhuyule.com/blog/Skill/Delphi下获取网络数据乱码问题.html","excerpt":"根据不同字符集的网页的内容的获取。","text":"根据不同字符集的网页的内容的获取。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 函数说明: 获取当前页面的Html源代码// @param AURL : 页面URL地址// @param ACharset: 页面字符集// @param AState : 成功状态//// @returns 返回成功状态(True表示成功,False表示失败)function GetHtmlContent(const AUrl, ACharset: string; var AState: Boolean): string;var vStrStream: TStringStream; //用于接收数据的流 vNetHandle, vURLHandle: HINTERNET; vBuffer: PChar; vReadSize: Cardinal; vCharsetInt: Integer;begin try if UpperCase(ACharset) = 'UTF-8' then vCharsetInt := 65001//4 else if UpperCase(ACharset) = 'GB2312' then vCharsetInt := 20936//2 else if Pos(UpperCase(ACharset), 'MacRoman,MacCroatian') &gt; 0 then vCharsetInt := 20127//1 else if Pos(UpperCase(ACharset), 'GB-2312,ASCII, KOI8-R,KOI8-U, ISO-8859-1..ISO-8859-16,') &gt; 0 then vCharsetInt := 20936//2 else if Pos(UpperCase(ACharset), 'UTF8,EUC-KR') &gt; 0 then vCharsetInt := 51932//3 else if Pos(UpperCase(ACharset), 'EUC-JP,UTF-32LE,UTF-32BE') &gt; 0 then vCharsetInt := 65001//4 else if Pos(UpperCase(ACharset), 'UTF-7,UTF7,') &gt; 0 then vCharsetInt := 65000 //6 else vCharsetInt := 65001; // 4 vStrStream := TStringStream.Create('', vCharsetInt); try GetMem(vBuffer, 65536); vReadSize := 0; vNetHandle := InternetOpen('Delphi', INTERNET_OPEN_TYPE_PRECONFIG, nil, nil, 0); vURLHandle := InternetOpenUrl(vNetHandle, PChar(AUrl), nil, 0, INTERNET_FLAG_RELOAD, 0); repeat InternetReadFile(vURLHandle, vBuffer, 1000, vReadSize); if vReadSize &lt;&gt; 0 then vStrStream.Write(vBuffer^, vReadSize); until vReadSize = 0; InternetCloseHandle(vURLHandle); InternetCloseHandle(vNetHandle); FreeMem(vBuffer); AState := True; Result := vStrStream.DataString; finally vStrStream.Free; end; except on e: Exception do begin AState := False; Result := '[Error]'+AUrl + '|' + e.Message; end; end;end; System.SysUtils.pas1234567891011121314151617181920212223242526272829303132...function GetCPInfo(CodePage: Cardinal; var lpCPInfo: TCPInfo): Boolean;begin Result := True; case CodePage of // Code page identifiers understood directly by iconv_open() 154, 367, 437, 737, 775, 819, 850, 852, 853, 855..858, 860..866, 869, 874, 922: lpCPInfo.MaxCharSize := 1; 932, 936, 943, 949, 950: lpCPInfo.MaxCharSize := 2; 1046, 1124, 1125, 1129, 1133, 1161, 1162, 1163, 1250..1258: lpCPInfo.MaxCharSize := 1; 1361: lpCPInfo.MaxCharSize := 2; // Code page indentifiers translated to iconv_open() encoding names (by LocaleNameFromCodePage) 10000, 10004..10007, 10010, 10017, 10021, 10029, 10079, 10081, 10082: lpCPInfo.MaxCharSize := 1; // MacRoman .. MacCroatian 12000, 12001: lpCPInfo.MaxCharSize := 4; // UTF-32LE, UTF-32BE 20127, 20866: lpCPInfo.MaxCharSize := 1; // ASCII, KOI8-R 20932: lpCPInfo.MaxCharSize := 3; // EUC-JP 20936: lpCPInfo.MaxCharSize := 2; // GB2312, EUC-KR 21866, 28591..28601, 28603..28606: lpCPInfo.MaxCharSize := 1; // KOI8-U, ISO-8859-1..ISO-8859-16 50221: lpCPInfo.MaxCharSize := 9; // ISO-2022-JP 50225: lpCPInfo.MaxCharSize := 7; // ISO-2022-KR 50227: lpCPInfo.MaxCharSize := 8; // ISO-2022-CN 51932: lpCPInfo.MaxCharSize := 3; // EUC-JP 51936, 51949: lpCPInfo.MaxCharSize := 2; // GB2312, EUC-KR 51950, 52936, 54936: lpCPInfo.MaxCharSize := 4; // EUC-TW, HZ-GB-2312, GB18030 65000: lpCPInfo.MaxCharSize := 6; // UTF-7 65001: lpCPInfo.MaxCharSize := 4; // UTF-8 else Result := False; end;end;...","categories":[{"name":"开发","slug":"开发","permalink":"https://zhuzhuyule.com/categories/开发/"}],"tags":[{"name":"Delphi","slug":"Delphi","permalink":"https://zhuzhuyule.com/tags/Delphi/"},{"name":"web","slug":"web","permalink":"https://zhuzhuyule.com/tags/web/"}]},{"title":"jqGrid中Json的解析","slug":"Front/jqGrid中Json的解析","date":"2017-09-05T08:41:31.000Z","updated":"2017-11-17T12:41:30.249Z","comments":true,"path":"blog/Front/jqGrid中Json的解析.html","link":"","permalink":"https://zhuzhuyule.com/blog/Front/jqGrid中Json的解析.html","excerpt":"这里主要说明一下在jqGrid中使用Json数据格式的响应，主要是配置jsonReader信息。","text":"这里主要说明一下在jqGrid中使用Json数据格式的响应，主要是配置jsonReader信息。 $(&quot;#jqGrid&quot;).jqGrid(&#123; url: &apos;./test/returnJSON&apos;, datatype: &quot;json&quot;, height: &quot;auto&quot;, rowNum: 30, colNames: [&apos;id&apos;,&apos;name&apos;, &apos;age&apos;, &apos;address&apos;], colModel: [ &#123; name: &apos;id&apos;, index: &apos;id&apos;, 350, sorttype: &quot;string&quot; &#125;, &#123; name: &apos;name&apos;, index: &apos;name&apos;, 350, sorttype: &quot;string&quot; &#125;, &#123; name: &apos;age&apos;, index: &apos;age&apos;, 350, sorttype: &quot;string&quot; &#125;, &#123; name: &apos;address&apos;, index: &apos;address&apos;, 580, sorttype: &quot;string&quot; &#125;, ], pager: &quot;#jqGridPage&quot;, viewrecords: true, sortorder: &quot;desc&quot;&#125;); 这里的json格式是很讲究的，必须遵循官方文档约定的格式，不能自由。可选的数据类型为json or jsonp, (or jsonstring)jqgrid读取json的时候，需要配置jsonReader才能读取，不过jsonReader有默认值，通常不需要做配置。jsonReader默认值如下 jQuery(\"#jqGrid\").jqGrid(&#123; ... jsonReader: &#123; root: \"rows\", //root这里的值是rows，意味着它会读取json中的rows键的值，这个值就是真实的数据 page: \"page\", //root这里的值是page，意味着它会读取json中的page键的值，当前页号 total: \"total\", //总的页数 records: \"records\", //总记录数 repeatitems: true, //如果设为false，则jqGrid在解析json时，会根据name来搜索对应的数据元素（即可以json中元素可以不按顺序）；而所使用的name是来自于colModel中的name设定。 cell: \"cell\", id: \"id\", userdata: \"userdata\", subgrid: &#123; root: \"rows\", repeatitems: true, cell: \"cell\" &#125; &#125;, ...&#125;); 如果数据类型是json，那么默认的期望得到的json字符串格式123456789&#123; &quot;total&quot;: &quot;20&quot;, &quot;page&quot;: &quot;2&quot;, &quot;records&quot;: &quot;55&quot;, &quot;rows&quot;: [&#123;&quot;id&quot;: &quot;1&quot;,&quot;cell&quot;: [&quot;cell11&quot;, &quot;cell12&quot;, &quot;cell13&quot;]&#125;, &#123;&quot;id&quot;: &quot;2&quot;,&quot;cell&quot;: [&quot;cell21&quot;, &quot;cell22&quot;, &quot;cell23&quot;]&#125;, ... ]&#125; JSON中Key 含义说明 total 总页数 page 当前页数 records 记录数 rows 包含真实数据的数组 id 每一行的唯一id cell 包含行的数据的数组 root元素这个root是描述数据的开始，也就是说root指明了一个包含数据的数组。如果我们设置如下： jQuery(\"#gridid\").jqGrid(&#123; ... jsonReader : &#123;root:\"invdata\"&#125;, ... &#125;); 那么返回的json字符串应该如下：123456789&#123; \"total\": \"20\", \"page\": \"2\", \"records\": \"55\", \"invdata\": [&#123;\"id\": \"1\",\"cell\": [\"cell11\", \"cell12\", \"cell13\"]&#125;, &#123;\"id\": \"2\",\"cell\": [\"cell21\", \"cell22\", \"cell23\"]&#125;, ... ]&#125; page，total，records如果我们设置如下：jQuery(\"#gridid\").jqGrid(&#123; ... jsonReader : &#123; root:\"invdata\", page: \"currpage\", total: \"totalpages\", records: \"totalrecords\" &#125;, ... &#125;); 那么返回的json字符串应该如下：123456789&#123; \"totalpages\": \"20\", \"currpage\": \"2\", \"totalpages\": \"55\", \"totalrecords\": [&#123;\"id\": \"1\",\"cell\": [\"cell11\", \"cell12\", \"cell13\"]&#125;, &#123;\"id\": \"2\",\"cell\": [\"cell21\", \"cell22\", \"cell23\"]&#125;, ... ]&#125; cell元素描述了包含行数据的数组，如果jsonReader如下设置jQuery(\"#gridid\").jqGrid(&#123; ... jsonReader : &#123; root:\"invdata\", page: \"currpage\", total: \"totalpages\", records: \"totalrecords\", cell: \"invrow\" &#125;, ... &#125;); 那么返回的json字符串应该如下： 123456789&#123; \"totalpages\": \"20\", \"currpage\": \"2\", \"totalrecords\": \"55\", \"invdata\": [&#123;\"id\": \"1\",\"invrow\": [\"cell11\", \"cell12\", \"cell13\"]&#125;, &#123;\"id\": \"2\",\"invrow\": [\"cell21\", \"cell22\", \"cell23\"]&#125;, ... ]&#125; id此元素描述了每一行的唯一的id值，如果jsonReader如下设置jQuery(\"#gridid\").jqGrid(&#123; ... jsonReader : &#123; root:\"invdata\", page: \"currpage\", total: \"totalpages\", records: \"totalrecords\", cell: \"invrow\", id: \"invid\" &#125;, ... &#125;); 那么返回的json字符串应该如下：123456789&#123; \"totalpages\": \"20\", \"currpage\": \"2\", \"totalrecords\": \"55\", \"invdata\": [&#123;\"invid\": \"1\",\"invrow\": [\"cell11\", \"cell12\", \"cell13\"]&#125;, &#123;\"invid\": \"2\",\"invrow\": [\"cell21\", \"cell22\", \"cell23\"]&#125;, ... ]&#125; 可以将cell元素设置为空字符串，也可以将id设置为数字，如果这样的话，例子如下jQuery(\"#gridid\").jqGrid(&#123; ... jsonReader : &#123; root:\"invdata\", page: \"currpage\", total: \"totalpages\", records: \"totalrecords\", cell: \"\", id: \"0\" //设为数字的话，rowid=第0个格子的内容，此处rowid=cell11，rowid=cell21 &#125;, ... &#125;); 这样的话，id就是行数据的第一个元素 那么返回的json字符串应该如下：123456789&#123; \"totalpages\": \"20\", \"currpage\": \"2\", \"totalrecords\": \"55\", \"invdata\": [ [\"cell11\", \"cell12\", \"cell13\"], [\"cell21\", \"cell22\", \"cell23\"], ... ]&#125; repeatitems此元素设置为ture,则cell里的元素顺序和colModel的顺序一致，按顺序显示。如果要让jqGrid根据json数据搜素元素，则把repeatable设置为false，此时设置cell属性无意义。 jQuery(&quot;#gridid&quot;).jqGrid(&#123;... jsonReader: &#123; root: &quot;invdata&quot;, page: &quot;currpage&quot;, total: &quot;totalpages&quot;, records: &quot;totalrecords&quot;, repeatitems: false, id: &quot;0&quot; &#125;, ...&#125;); 期望的json字符串如下:12345678910&#123; &quot;totalpages&quot;: &quot;20&quot;, &quot;currpage&quot;: &quot;2&quot;, &quot;totalrecords&quot;: &quot;55&quot;, &quot;invdata&quot;: [ &#123; &quot;invid&quot;: &quot;1&quot;, &quot;invdate&quot;: &quot;cell11&quot;, &quot;amount&quot;: &quot;cell12&quot;, &quot;tax&quot;: &quot;cell13&quot;, &quot;total&quot;: &quot;1234&quot;, &quot;note&quot;: &quot;somenote&quot; &#125;, &#123; &quot;invid&quot;: &quot;2&quot;, &quot;invdate&quot;: &quot;cell21&quot;, &quot;amount&quot;: &quot;cell22&quot;, &quot;tax&quot;: &quot;cell23&quot;, &quot;total&quot;: &quot;2345&quot;, &quot;note&quot;: &quot;some note&quot; &#125;, ... ]&#125; 此时，id就是第0个元素，即invid的值 总结的说 repeatitems是true的情况下， id是数字表示rowdata里面的位置，即cell里的位置，repeatitems是false的情况下， id是数字直接代表在json里面的位置。repeatitems:false 设为false是很有用的，这样的话就不必按照colModel的顺序来组件model。","categories":[{"name":"前端","slug":"前端","permalink":"https://zhuzhuyule.com/categories/前端/"},{"name":"JS","slug":"前端/JS","permalink":"https://zhuzhuyule.com/categories/前端/JS/"}],"tags":[{"name":"jqGrid","slug":"jqGrid","permalink":"https://zhuzhuyule.com/tags/jqGrid/"}]},{"title":"如何实现一个高效的队列","slug":"Experiences/如何实现一个高效的队列","date":"2017-08-02T09:25:59.000Z","updated":"2018-02-06T08:56:10.549Z","comments":true,"path":"blog/Experiences/如何实现一个高效的队列.html","link":"","permalink":"https://zhuzhuyule.com/blog/Experiences/如何实现一个高效的队列.html","excerpt":"1 队列简介 队列(Queue)是运算受限的线性表。一种先进先出(First In First Out ，简称FIFO)的线性表。只允许在表的一端进行插入，而在另一端进行删除。先进先出 是队列特有的性质。 举例来说 我们购买东西需要排队，而这个排好的队伍就是队列。先来的人可以先买到东西离开。 乘坐电动扶梯时，乘客都是从扶梯的一头进入，另一头离开电梯。先上电梯的乘客，先下电梯。","text":"1 队列简介 队列(Queue)是运算受限的线性表。一种先进先出(First In First Out ，简称FIFO)的线性表。只允许在表的一端进行插入，而在另一端进行删除。先进先出 是队列特有的性质。 举例来说 我们购买东西需要排队，而这个排好的队伍就是队列。先来的人可以先买到东西离开。 乘坐电动扶梯时，乘客都是从扶梯的一头进入，另一头离开电梯。先上电梯的乘客，先下电梯。 2 逻辑与实现2.1 队列的基本功能理解完队列概念，再来列出队列具有的功能： 插入 向队列 队尾 增加一个对象。 弹出 从队列 队首 弹出一个对象。 计数 计算当前队列中数据的总个数。 2.2 队列的需要的变量好了，功能也有了，现在来更具这些功能来准备准备我们的材料： 单位容量 FCapacity 总要告诉内存你每次打算征用人家多少区域来给你排队用吧。 一块内存 FMem 更具你的单位容量，去申请‘场地’来排队用，用完了再来申请。 队尾计数器 FPopIndex 有了它，你就知道你在队伍里排的多少号了。 队首计数器 FPushIndex 有了它，你就只当队伍最前面的人拍的是几号了。 2.3 队列实现2.3.1 初始化先来初始化队列，设置容量并重置计数器。123456789PageCapacity = 7;//初始化 计数器FPushIndex = 0;FPopIndex = 0;//更具容量申请 固定大小的空间SetLength(FMem, PageCapacity);FCapacity = PageCapacity; 2.3.2 载入数据向队列加载数据时，队尾计数器自加，自加后如果发现 排号和容量大小一样了，说明空间不够了，就向商场（内存）申请连续的扩容空间（已用空间大小+单位容量）12345678910//新来的元素放到空间末尾FMem[FPushIndex] = NewItem;//每加载一个新的元素进来，都要增加FPushIndexFPushIndex = FPushIndex + 1;//这里还需要保证 队尾 计数器始终小于 总容量 ，否则 要扩容if (FPushIndex &gt;= FCapacity) SetLength(FMem, FCapacity+ PageCapacity); FCapacity = FCapacity + PageCapacity; 2.3.3 弹出数据好了，现在队伍有了，该卖东西了，正真的队伍是卖一个走一个，所以我们按照号码(内存下标)来叫号卖。1234//按照 队首 下标开始 获取元素( FPopIndex 前提小于 排队人数 FPushIndex )if FPopIndex &lt; FPushIndex PopItem = FMem[FPopIndex]; FPopIndex = FPopIndex + 1; //每弹出一个元素，都要增加FPopIndex 弹出数据的过程中也会有新的数据来加载，但是不影响我们改变内存的规律： 载入数据 直接将数据放到队列末尾 队尾计数器 +1 判断内存是否足够 弹出数据 拿出队首计数器指向数据 队首计数器 +1 2.4 代码实现废话说了这么多，好了贴代码。代码功能说明： 基本功能 载入功能 弹出功能 清空队列功能 队列计数功能 自动扩容功能 拓展功能 为了线程安全，使用临界区加锁控制 字符串加载/弹出功能 容量设置功能 代码如下：.\\FastQueue.pas123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254unit FastDemo;interface//线程安全版本uses Windows, SysUtils;const CONST_BYTE_SIZE = 4; CONST_PAGE_SINGLE = 1024; COSNT_PAGE_SINGLE_SIZE = CONST_PAGE_SINGLE * CONST_BYTE_SIZE;type TFastQueue = class private FCS: TRTLCriticalSection; // FMem: Pointer; FTmpMem: Pointer; // FPushIndex: Integer; //压入队列计数器 FPopIndex: Integer; //弹出队列计数器 FCapacity: Integer; //队列容量，始终大于 FPushIndex // procedure Lock(); procedure UnLock(); procedure SetCapacity(const AValue: Integer); // procedure setSynCapacity(const AValue: Integer); function getSynCapacity: Integer; function getSynCurCount: Integer; public constructor Create(AInitCapacity: Integer = CONST_PAGE_SINGLE); destructor Destroy(); override; // function Push(AItem: Pointer): Pointer; function Pop(): Pointer; function PushString(AItem: string): Pointer; function PopString(): string; procedure Clear; public property Capacity: Integer read getSynCapacity write setSynCapacity; property Count: Integer read getSynCurCount; end;implementation&#123; TFastQueue &#125;constructor TFastQueue.Create(AInitCapacity: Integer);begin InitializeCriticalSection(FCS); FPushIndex := 0; FPopIndex := 0; if AInitCapacity &lt; CONST_PAGE_SINGLE then AInitCapacity := CONST_PAGE_SINGLE; SetCapacity(AInitCapacity);end;destructor TFastQueue.Destroy;begin FreeMem(FMem); if FTmpMem &lt;&gt; nil then FreeMem(FTmpMem); DeleteCriticalSection(FCS); inherited;end;procedure TFastQueue.Lock;begin EnterCriticalSection(FCS);end;procedure TFastQueue.UnLock;begin LeaveCriticalSection(FCS);end;procedure TFastQueue.SetCapacity(const AValue: Integer);var vPageCount, vOldSize, vNewSize: Integer;begin if AValue &gt; FCapacity then begin if FTmpMem &lt;&gt; nil then FreeMem(FTmpMem); vPageCount := AValue div CONST_PAGE_SINGLE; if (AValue mod CONST_PAGE_SINGLE) &gt; 0 then Inc(vPageCount); //保存旧的容量 vOldSize := FCapacity * CONST_BYTE_SIZE; //计算新的容量 FCapacity := vPageCount * CONST_PAGE_SINGLE; vNewSize := FCapacity * CONST_BYTE_SIZE; //扩容 GetMem(FTmpMem, vNewSize); FillChar(FTmpMem^, vNewSize, #0); //转移数据 if FMem &lt;&gt; nil then begin Move(FMem^, FTmpMem^, vOldSize); FreeMem(FMem); end; FMem := FTmpMem; //FTmpMem （保证弹出、插入数据时使用） 与 FMem 大小一致 GetMem(FTmpMem, vNewSize); end;end;function TFastQueue.Push(AItem: Pointer): Pointer;var vPMem: PInteger; vNextPriority, vPriority, vIndex: Integer; vNotPushed: boolean;begin Lock(); try vPMem := PInteger(FMem); Inc(vPMem, FPushIndex); vPMem^ := Integer(AItem); Inc(FPushIndex); //检测栈容量是否足够（至少保留一位空位，否则扩容 1024） if FPushIndex &gt;= FCapacity then begin SetCapacity(FCapacity + CONST_PAGE_SINGLE); end; finally UnLock(); end;end;function TFastQueue.Pop: Pointer; procedure MoveMem(); var vvPSrc: PInteger; vvTmpMem: Pointer; begin FillChar(FTmpMem^, FCapacity * CONST_BYTE_SIZE, #0); vvPSrc := PInteger(FMem); Inc(vvPSrc, FPopIndex); Move(vvPSrc^, FTmpMem^, (FCapacity - FPopIndex) * CONST_BYTE_SIZE); //交换指针 vvTmpMem := FMem; FMem := FTmpMem; FTmpMem := vvTmpMem; end;var vPMem: PInteger;begin Lock(); try Result := nil; if (FPopIndex = FPushIndex) then Exit; // 1.获取弹出元素 vPMem := PInteger(FMem); Inc(vPMem, FPopIndex); Result := Pointer(vPMem^); // 2.弹出元素后 弹出计数器 +1 Inc(FPopIndex); // 3.队列底部空余内存达到 1024 整体迁移 if FPopIndex = CONST_PAGE_SINGLE then begin //迁移数据 MoveMem(); //重置弹出位置 FPopIndex := 0; //减少压入队列的数量 Dec(FPushIndex, CONST_PAGE_SINGLE); end; finally UnLock(); end;end;function TFastQueue.PushString(AItem: string): Pointer;var vPChar: PChar;begin vPChar := StrAlloc(256); StrCopy(vPChar, pchar(AItem + ' |' + inttostr(FPushIndex))); Push(vPChar);end;function TFastQueue.PopString: string;var vPChar: PChar;begin Result := 'nil'; vPChar := Pop; if vPChar &lt;&gt; '' then begin Result := vPChar; StrDispose(vPChar); end;end;procedure TFastQueue.Clear;begin Lock(); try FPushIndex := 0; FPopIndex := 0; SetCapacity(CONST_PAGE_SINGLE); finally UnLock(); end;end;procedure TFastQueue.setSynCapacity(const AValue: Integer);begin Lock(); try SetCapacity(AValue); finally UnLock(); end;end;function TFastQueue.getSynCapacity: Integer;begin Lock(); try Result := FCapacity; finally UnLock(); end;end;function TFastQueue.getSynCurCount: Integer;begin Lock(); try Result := FPushIndex - FPopIndex; finally UnLock(); end;end;end. 2.5 使用Demo12345678910111213141516171819202122procedure UseFastQueue();var vQueue: TFastQueue;begin vQueue := TFastQueue.Create; try vQueue.Push('A1'); vQueue.Push('A2'); vQueue.Push('A3'); vQueue.Push('A4'); vQueue.Push('A5'); vQueue.Push('A6'); while vQueue.Count &gt; 0 do begin OutputDebugString(vQueue.PopString); end; finally vQueue.Free; vQueue := nil; end;end; 输出: A1A2A3A4A5","categories":[{"name":"经验总结","slug":"经验总结","permalink":"https://zhuzhuyule.com/categories/经验总结/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"https://zhuzhuyule.com/tags/Queue/"}]},{"title":"使用完会上瘾的工具集合","slug":"Experiences/使用完会上瘾的工具集合","date":"2017-06-28T11:52:32.000Z","updated":"2018-02-06T08:56:10.969Z","comments":true,"path":"blog/Experiences/使用完会上瘾的工具集合.html","link":"","permalink":"https://zhuzhuyule.com/blog/Experiences/使用完会上瘾的工具集合.html","excerpt":"个人使用觉得挺好的软件集合，这里摘录一下！","text":"个人使用觉得挺好的软件集合，这里摘录一下！ 图片操作 截图软件 Snipaste (专注截图) ShareX | Github (侧重分享) 高质量图片放大 waifu2x | Github waifu2x-caffe (PC) 资源管理 文件搜索 Everything 资源预览工具 QuickLook | Github Seer 文件资源管理器增强工具 Listary 剪贴板增强工具 Ditto 鼠键工具 快速启动工具 AltRun | Github 全局鼠标手势 WGestures | Github 键盘利器 CapsLock+ AutoHotKey 翻译 简洁且快速的翻译工具 QTranslate | Download","categories":[{"name":"Soft","slug":"Soft","permalink":"https://zhuzhuyule.com/categories/Soft/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"https://zhuzhuyule.com/tags/Tool/"}]},{"title":"HEXO优化之（二）----添加复制功能","slug":"HEXO/HEXO优化之（二）-添加复制功能","date":"2017-06-12T11:39:59.000Z","updated":"2018-02-06T08:56:13.198Z","comments":true,"path":"blog/HEXO/HEXO优化之（二）-添加复制功能.html","link":"","permalink":"https://zhuzhuyule.com/blog/HEXO/HEXO优化之（二）-添加复制功能.html","excerpt":"这月工作比较繁忙，所以这篇文章出的晚了，本次先把我文章内的复制功能的实现代码贴出来，如果对其他功能还有需要的，请留言给我，我会整理出来分享给大家！好了，废话说完了 ，这就开始正题。","text":"这月工作比较繁忙，所以这篇文章出的晚了，本次先把我文章内的复制功能的实现代码贴出来，如果对其他功能还有需要的，请留言给我，我会整理出来分享给大家！好了，废话说完了 ，这就开始正题。 概要 应用第三方插件clipboard.js 使用JQuery操作显示位置 支持浏览器 Chrome 42+ Edge 12+ Firefox 41+ IE 9+ Opera 29+ Safari 10+ 下载插件clipboard.jsclipboard.js（这里我不赘述了，直接贴主页/GitHub） 主页 GitHub 提供下载 clipboard.js clipboard.min.js （推荐） 保存文件clipboard.js / clipboard.min.js （推荐），目录如下：（相对目录为工程目录） .\\themes\\next\\source\\lib\\zclip\\clipboard.min.js 新增 插入JavaScript新建文件 custom.js ，目录如下：（相对目录为工程目录） .\\themes\\next\\source\\js\\src\\custom.js 新增 .\\themes\\next\\source\\js\\src\\custom.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//此函数用于创建复制按钮function createCopyBtns() &#123; var $codeArea = $(\"figure table\"); //查看页面是否具有代码区域，没有代码块则不创建 复制按钮 if ($codeArea.length &gt; 0) &#123; //复制成功后将要干的事情 function changeToSuccess(item) &#123; $imgOK = $(\"#copyBtn\").find(\"#imgSuccess\"); if ($imgOK.css(\"display\") == \"none\") &#123; $imgOK.css(&#123; opacity: 0, display: \"block\" &#125;); $imgOK.animate(&#123; opacity: 1 &#125;, 1000); setTimeout(function() &#123; $imgOK.animate(&#123; opacity: 0 &#125;, 2000); &#125;, 2000); setTimeout(function() &#123; $imgOK.css(\"display\", \"none\"); &#125;, 4000); &#125;; &#125;; //创建 全局复制按钮，仅有一组。包含：复制按钮，复制成功响应按钮 //值得注意的是：1.按钮默认隐藏，2.位置使用绝对位置 position: absolute; (position: fixed 也可以，需要修改代码) $(\".post-body\").before('&lt;div id=\"copyBtn\" style=\"opacity: 0; position: absolute;top:0px;display: none;line-height: 1; font-size:1.5em\"&gt;&lt;span id=\"imgCopy\" &gt;&lt;i class=\"fa fa-paste fa-fw\"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span id=\"imgSuccess\" style=\"display: none;\"&gt;&lt;i class=\"fa fa-check-circle fa-fw\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/span&gt;'); //创建 复制 插件，绑定单机时间到 指定元素，支持JQuery var clipboard = new Clipboard('#copyBtn', &#123; target: function() &#123; //返回需要复制的元素内容 return document.querySelector(\"[copyFlag]\"); &#125;, isSupported: function() &#123; //支持复制内容 return document.querySelector(\"[copyFlag]\"); &#125; &#125;); //复制成功事件绑定 clipboard.on('success', function(e) &#123; //清除内容被选择状态 e.clearSelection(); changeToSuccess(e); &#125;); //复制失败绑定事件 clipboard.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger); &#125;); //鼠标 在复制按钮上滑动和离开后渐变显示/隐藏效果 $(\"#copyBtn\").hover( function() &#123; $(this).stop(); $(this).css(\"opacity\", 1); &#125;, function() &#123; $(this).animate(&#123; opacity: 0 &#125;, 2000); &#125; ); &#125;&#125;//感应鼠标是否在代码区$(\"figure\").hover( function() &#123; //-------鼠标活动在代码块内 //移除之前含有复制标志代码块的 copyFlag $(\"[copyFlag]\").removeAttr(\"copyFlag\"); //在新的（当前鼠标所在代码区）代码块插入标志：copyFlag $(this).find(\".code\").attr(\"copyFlag\", 1); //获取复制按钮 $copyBtn = $(\"#copyBtn\"); if ($copyBtn.lenght != 0) &#123; //获取到按钮的前提下进行一下操作 //停止按钮动画效果 //设置为 显示状态 //修改 复制按钮 位置到 当前代码块开始部位 //设置代码块 左侧位置 $copyBtn.stop(); $copyBtn.css(\"opacity\", 0.8); $copyBtn.css(\"display\", \"block\"); $copyBtn.css(\"top\", parseInt($copyBtn.css(\"top\")) + $(this).offset().top - $copyBtn.offset().top + 3); $copyBtn.css(\"left\", -$copyBtn.width() - 3); &#125; &#125;, function() &#123; //-------鼠标离开代码块 //设置复制按钮可见度 2秒内到 0 $(\"#copyBtn\").animate(&#123; opacity: 0 &#125;, 2000); &#125;);//页面载入完成后，创建复制按钮$(document).ready(function() &#123; createCopyBtns();&#125;); 插入主题中新建文件 custom.swig ，目录如下：（相对目录为工程目录） .\\themes\\next\\layout_custom\\custom.swig 新增 .\\themes\\next\\layout\\_custom\\custom.swig12&lt;script type=\"text/javascript\" src=\"/lib/zclip/clipboard.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/js/src/custom.js\"&gt;&lt;/script&gt; 修改文件 _layout.swig ，目录如下：（相对目录为工程目录） .\\themes\\next\\layout_layout.swig 修改 .\\themes\\next\\layout\\_layout.swig1234567891011121314151617&lt;!doctype html&gt;...&lt;html class=\"&#123;&#123; html_class | lower &#125;&#125;\" lang=\"&#123;&#123; config.language &#125;&#125;\"&gt;&lt;head&gt; ...&lt;/head&gt;&lt;body itemscope itemtype=\"https://schema.org/WebPage\" lang=\"&#123;&#123; page.lang || page.language || config.language &#125;&#125;\"&gt; ... ... &#123;% include '_third-party/mathjax.swig' %&#125; &#123;% include '_third-party/scroll-cookie.swig' %&#125; &#123;% include '_third-party/exturl.swig' %&#125; &#123;% include '_custom/custom.swig' %&#125;&lt;/body&gt;&lt;/html&gt; 向文件中&lt;/body&gt;前一行插入文件引用，如第15行效果。&#123;% include &apos;_custom/custom.swig&apos; %&#125; 总结至此，代码复制 功能添加完毕，所有文件添加及修改状态如下 .\\themes\\next\\source\\lib\\zclip\\clipboard.min.js 新增.\\themes\\next\\source\\js\\src\\custom.js 新增.\\themes\\next\\layout\\_custom\\custom.swig 新增 （感谢@heliuphy发现问题！） .\\themes\\next\\layout_layout.swig 修改 运行起来看看效果吧！ 注意点 相对目录都以 工程目录 为 根目录 本文内容使用 jQuery v2.1.3 HEXO主题 NexT 图标库 Font Awesome (NexT主题内嵌)","categories":[{"name":"前端","slug":"前端","permalink":"https://zhuzhuyule.com/categories/前端/"},{"name":"Hexo","slug":"前端/Hexo","permalink":"https://zhuzhuyule.com/categories/前端/Hexo/"}],"tags":[{"name":"Hexo优化系列","slug":"Hexo优化系列","permalink":"https://zhuzhuyule.com/tags/Hexo优化系列/"},{"name":"clipboardjs","slug":"clipboardjs","permalink":"https://zhuzhuyule.com/tags/clipboardjs/"}]},{"title":"SqliteLite错误码整理","slug":"Skill/SqliteLite错误码整理","date":"2017-04-19T02:38:10.000Z","updated":"2018-02-06T08:56:08.920Z","comments":true,"path":"blog/Skill/SqliteLite错误码整理.html","link":"","permalink":"https://zhuzhuyule.com/blog/Skill/SqliteLite错误码整理.html","excerpt":"这篇文章主要介绍了SQLite 错误码，方便大家在开发过程中快速解决问题!","text":"这篇文章主要介绍了SQLite 错误码，方便大家在开发过程中快速解决问题! 12345678910111213141516171819202122232425262728293031#define SQLITE_OK 0 /* 成功 | Successful result *//* 错误码开始 */#define SQLITE_ERROR 1 /* SQL错误 或 丢失数据库 | SQL error or missing database */#define SQLITE_INTERNAL 2 /* SQLite 内部逻辑错误 | Internal logic error in SQLite */#define SQLITE_PERM 3 /* 拒绝访问 | Access permission denied */#define SQLITE_ABORT 4 /* 回调函数请求取消操作 | Callback routine requested an abort */#define SQLITE_BUSY 5 /* 数据库文件被锁定 | The database file is locked */#define SQLITE_LOCKED 6 /* 数据库中的一个表被锁定 | A table in the database is locked */#define SQLITE_NOMEM 7 /* 某次 malloc() 函数调用失败 | A malloc() failed */#define SQLITE_READONLY 8 /* 尝试写入一个只读数据库 | Attempt to write a readonly database */#define SQLITE_INTERRUPT 9 /* 操作被 sqlite3_interupt() 函数中断 | Operation terminated by sqlite3_interrupt() */#define SQLITE_IOERR 10 /* 发生某些磁盘 I/O 错误 | Some kind of disk I/O error occurred */#define SQLITE_CORRUPT 11 /* 数据库磁盘映像不正确 | The database disk image is malformed */#define SQLITE_NOTFOUND 12 /* sqlite3_file_control() 中出现未知操作数 | Unknown opcode in sqlite3_file_control() */#define SQLITE_FULL 13 /* 因为数据库满导致插入失败 | Insertion failed because database is full */#define SQLITE_CANTOPEN 14 /* 无法打开数据库文件 | Unable to open the database file */#define SQLITE_PROTOCOL 15 /* 数据库锁定协议错误 | Database lock protocol error */#define SQLITE_EMPTY 16 /* 数据库为空 | Database is empty */#define SQLITE_SCHEMA 17 /* 数据结构发生改变 | The database schema changed */#define SQLITE_TOOBIG 18 /* 字符串或二进制数据超过大小限制 | String or BLOB exceeds size limit */#define SQLITE_CONSTRAINT 19 /* 由于约束违例而取消 | Abort due to constraint violation */#define SQLITE_MISMATCH 20 /* 数据类型不匹配 | Data type mismatch */#define SQLITE_MISUSE 21 /* 不正确的库使用 | Library used incorrectly */#define SQLITE_NOLFS 22 /* 使用了操作系统不支持的功能 | Uses OS features not supported on host */#define SQLITE_AUTH 23 /* 授权失败 | Authorization denied */#define SQLITE_FORMAT 24 /* 附加数据库格式错误 | Auxiliary database format error */#define SQLITE_RANGE 25 /* 传递给sqlite3_bind()的第二个参数超出范围 | 2nd parameter to sqlite3_bind out of range */#define SQLITE_NOTADB 26 /* 被打开的文件不是一个数据库文件 | File opened that is not a database file */#define SQLITE_ROW 100 /* sqlite3_step() 已经产生一个行结果 | sqlite3_step() has another row ready */#define SQLITE_DONE 101 /* sqlite3_step() 完成执行操作 | sqlite3_step() has finished executing *//* 错误码结束 */ 原文链接","categories":[{"name":"总结","slug":"总结","permalink":"https://zhuzhuyule.com/categories/总结/"}],"tags":[{"name":"Sqlite","slug":"Sqlite","permalink":"https://zhuzhuyule.com/tags/Sqlite/"}]},{"title":"Nodepade","slug":"Skill/Nodepade","date":"2017-04-10T14:37:06.000Z","updated":"2017-05-31T02:52:17.195Z","comments":true,"path":"blog/Skill/Nodepade.html","link":"","permalink":"https://zhuzhuyule.com/blog/Skill/Nodepade.html","excerpt":"有点子，就该随时记录下来。本文置顶，仅仅对个人记事用。","text":"有点子，就该随时记录下来。本文置顶，仅仅对个人记事用。 好用的 CSS 样式","categories":[{"name":"随手记","slug":"随手记","permalink":"https://zhuzhuyule.com/categories/随手记/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"https://zhuzhuyule.com/tags/随手记/"}]},{"title":"Visual Studio Code 常用快捷键","slug":"Experiences/Visual-Studio-Code-常用快捷键","date":"2017-03-21T08:21:12.000Z","updated":"2017-05-16T12:34:09.134Z","comments":true,"path":"blog/Experiences/Visual-Studio-Code-常用快捷键.html","link":"","permalink":"https://zhuzhuyule.com/blog/Experiences/Visual-Studio-Code-常用快捷键.html","excerpt":"主命令框F1 或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如： 按一下 Backspace 会进入到 Ctrl+P 模式 在 Ctrl+P 下输入 &gt; 可以进入 Ctrl+Shift+P 模式 在 Ctrl+P 窗口下还可以: 文件名 跳转到对应文件 ? 列出当前可执行的动作 ! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M : 跳转到行数，也可以 Ctrl+G 直接进入 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 # 根据名字查找 symbol，也可以 Ctrl+T","text":"主命令框F1 或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如： 按一下 Backspace 会进入到 Ctrl+P 模式 在 Ctrl+P 下输入 &gt; 可以进入 Ctrl+Shift+P 模式 在 Ctrl+P 窗口下还可以: 文件名 跳转到对应文件 ? 列出当前可执行的动作 ! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M : 跳转到行数，也可以 Ctrl+G 直接进入 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 # 根据名字查找 symbol，也可以 Ctrl+T 常用快捷键编辑器与终端窗口管理同时打开多个终端窗口（查看多个项目） Ctrl+Shift+N 打开一个新窗口 Ctrl+Shift+W 关闭窗口 同时打开多个编辑器（查看多个文件） Ctrl+N 新建文件 Ctrl+Tab 文件之间切换 Ctrl+\\ 切出一个新的编辑器（最多 3 个） ，也可以按住 Ctrl + 鼠标点击 Explorer 里的文件名 Ctrl+1、Ctrl+2、Ctrl+3左中右 3 个编辑器的快捷键 Ctrl+ ` 3 个编辑器之间循环切换 Ctrl+k然后按 ←/→ 编辑器换位置 代码编辑格式调整 Ctrl+[ 、 Ctrl+] 代码行缩进 Ctrl+C/X 复制/剪切 当前行/当前选中内容 Shift+Alt+F 代码格式化,或 Ctrl+Shift+P 后输入format code Alt+↑/↓ 上/下移动一行 Shift+Alt+↑/↓ 向上/向下复制一行 Ctrl+Enter 在当前行下边插入一行 Ctrl+Shift+Enter 在当前行上方插入一行 光标相关 Home 移动到行首 End 移动到行尾 Ctrl+End 移动到文件结尾 Ctrl+Home 移动到文件开头 F12 移动到定义处 Alt+F12 定义处缩略图（只看一眼而不跳转过去） Ctrl+Shift+] 移动到后半个括号 Shift+End 选择从光标到行尾 Shift+Home 选择从行首到光标处 Ctrl+Delete 删除光标右侧的所有字 Shift+Alt+←/→ 扩展/缩小选取范围 Ctrl+Alt+↑/↓，Alt+Shift+鼠标左键 多行编辑(列编辑) Ctrl+Shift+L 同时选中所有匹配 Ctrl+D 下一个匹配的也被选中 Ctrl+U 回退上一个光标操作 重构代码 Shift+F12 找到所有的引用 Ctrl+F12 同时修改本文件中所有匹配的 F2 重命名比如要修改一个方法名，可以选中后按 ，输入新的名字，回车，会发现所有的文件都修改了 F8 跳转到下一个 Error 或 Warning，当有多个错误时可以按 逐个跳转 查看 diff; 在 explorer 里选择文件右键-&gt; Set file to compare-&gt;需要对比的文件上右键选择-&gt;Compare with file_name_you_chose 查找替换 Ctrl+F 查找 Ctrl+H 查找替换 Ctrl+Shift+F 整个文件夹中查找 显示相关 F11全屏 Ctrl +/- zoomIn/zoomOut Ctrl+B 侧边栏显/隐 Ctrl+Shift+E 显示资源管理器 Ctrl+Shift+F 显示搜索 Ctrl+Shift+G 显示 Git Ctrl+Shift+D 显示 Debug Ctrl+Shift+U 显示 Output 其他自动保存File -&gt; AutoSave ，或 Ctrl+Shift+P，输入 auto 修改默认快捷键 打开默认键盘快捷方式设置：File-&gt;Preferences-&gt;Keyboard Shortcuts，或Alt+F-&gt;p-&gt;k 修改 keybindings.json：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Place your key bindings in this file to overwrite the defaults[ // ctrl+l 快速切换编辑器语言 &#123; \"key\": \"ctrl+l\", \"command\": \"workbench.action.editor.changeEncoding\", \"when\": \"editorFocus\" &#125;, // ctrl+] 在explorer.exe中打开当前编辑文件 &#123; \"key\": \"ctrl+]\", \"command\": \"workbench.action.files.revealActiveFileInWindows\", \"when\": \"editorFocus\" &#125;, // ctrl+shift+] 定位到VSCode资源管理器位置 &#123; \"key\": \"ctrl+shift+]\", \"command\": \"workbench.files.action.showActiveFileInExplorer\", \"when\": \"editorFocus\" &#125;, // ctrl+space 被切换输入法快捷键占用 &#123; \"key\": \"alt+space\", \"command\": \"editor.action.triggerSuggest\", \"when\": \"editorTextFocus\" &#125;, // ctrl+d 删除一行 &#123; \"key\": \"ctrl+d\", \"command\": \"editor.action.deleteLines\", \"when\": \"editorTextFocus\" &#125;, // 与删除一行的快捷键互换 &#123; \"key\": \"ctrl+shift+k\", \"command\": \"editor.action.addSelectionToNextFindMatch\", \"when\": \"editorFocus\" &#125;, // ctrl+shift+/多行注释 &#123; \"key\": \"ctrl+shift+/\", \"command\": \"editor.action.blockComment\", \"when\": \"editorTextFocus\" &#125;, // 定制与 sublime 相同的大小写转换快捷键，需安装 TextTransform 插件 &#123; \"key\": \"ctrl+k ctrl+u\", \"command\": \"uppercase\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+k ctrl+l\", \"command\": \"lowercase\", \"when\": \"editorTextFocus\" &#125;] 前端开发必备插件 PostCSS Sorting stylelint stylefmt ESLint javascript standard format beautify Babel ES6/ES7 Debugger for Chrome Add jsdoc comments javascript(ES6) code snippets vue weex Reactjs code snippets React Native Tools Npm Intellisense Instant Markdown Markdown Shortcuts TextTransform 自定义设置参考VS Code 自定义配置参考：123456789101112131415161718192021&#123; \"editor.fontSize\": 18, \"files.associations\": &#123; \"*.es\": \"javascript\", \"*.es6\": \"javascript\" &#125;, // 控制编辑器是否应呈现空白字符 \"editor.renderWhitespace\": true, // 启用后，将在保存文件时剪裁尾随空格。 \"files.trimTrailingWhitespace\": true, // File extensions that can be beautified as javascript or JSON. \"beautify.JSfiles\": [ \"\", \"es\", \"es6\", \"js\", \"json\", \"jsbeautifyrc\", \"jshintrc\" ]&#125; 相关参考 官方快捷键大全","categories":[{"name":"Skill","slug":"Skill","permalink":"https://zhuzhuyule.com/categories/Skill/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://zhuzhuyule.com/tags/VSCode/"}]},{"title":"Gulp-Plgues","slug":"HEXO/Gulp-Plgues","date":"2017-03-17T03:09:58.000Z","updated":"2018-02-06T08:56:07.995Z","comments":true,"path":"blog/HEXO/Gulp-Plgues.html","link":"","permalink":"https://zhuzhuyule.com/blog/HEXO/Gulp-Plgues.html","excerpt":"实用的Gulp插件，帮助你的博客更加精简，快速。 易于使用 通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。 构建快速 利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 插件高质 Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 易于学习 通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。","text":"实用的Gulp插件，帮助你的博客更加精简，快速。 易于使用 通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。 构建快速 利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 插件高质 Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 易于学习 通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 安装先拷贝/创建如下文件 package.jsonpackage.json1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"3.4.0\" &#125;, \"dependencies\": &#123; \"browser-sync\": \"^2.18.13\", \"hexo\": \"^3.2.0\", \"hexo-deployer-git\": \"^0.3.0\", \"hexo-generator-archive\": \"^0.1.4\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-index\": \"^0.2.1\", \"hexo-generator-index2\": \"0.0.1\", \"hexo-generator-searchdb\": \"^1.0.7\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-renderer-ejs\": \"^0.2.0\", \"hexo-renderer-marked\": \"^0.2.10\", \"hexo-renderer-stylus\": \"^0.3.1\", \"hexo-server\": \"^0.2.2\" &#125;, \"devDependencies\": &#123; \"gulp-asset-rev\": \"^0.0.15\", \"gulp-clean-css\": \"^3.9.0\", \"gulp-concat\": \"^2.6.1\", \"gulp-debug\": \"^3.1.0\", \"gulp-htmlclean\": \"^2.7.15\", \"gulp-htmlmin\": \"^3.0.0\", \"gulp-if\": \"^2.0.2\", \"gulp-changed\": \"^3.1.0\", \"gulp-make-css-url-version\": \"^0.0.13\", \"gulp-modify-css-urls\": \"^0.2.2\", \"gulp-plumber\": \"^1.1.0\", \"gulp-uglify\": \"^3.0.0\", \"gulp-useref\": \"^3.1.2\", \"gulp-util\": \"^3.0.8\", \"hexo-deployer-git\": \"^0.3.1\", \"hexo-encrypt\": \"^0.5.1\", \"hexo-generator-json-content\": \"^3.0.1\", \"hexo-generator-search\": \"^2.1.1\", \"hexo-generator-searchdb\": \"^1.0.8\", \"hexo-server\": \"^0.2.2\", \"run-sequence\": \"^2.2.0\" &#125;&#125; 然后输入12npm config set registry https://registry.npm.taobao.orgnpm install 或者12npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install 会直接安装 package.json 文件中的插件，或者可以手动一个一个安装，方式如下：1234567npm install --save-dev gulp-concatnpm install --save-dev gulp-clean-cssnpm install --save-dev gulp-uglifynpm install --save-dev gulp-htmlminnpm install --save-dev gulp-htmlcleannpm install --save-dev gulp-imagemin... gulp-concat–合并javascript文件，减少网络请求文档 gulp-clean-css–压缩css文件，减小文件大小，并给引用url添加版本号避免缓存文档 gulp-uglify–压缩javascript文件，减小文件大小文档 gulp-htmlmin–压缩html，可以压缩页面javascript、css，去除页面空格、注释，删除多余属性等操作文档 gulp-htmlclean–清理html中的部分内容 gulp-imagemin–压缩 png/jpg/git/svg 格式图片文件文档 browser-sync–保持多浏览器、多设备同步、在前端开发是非常有用，可谓是必备组件。文档 hexo-encrypt– 加密网页内容，输入密码可查看文档 github 配置根目录下新建文件：gulpfile.jsgulpfile.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* npm install 超时请使用：(两条命令在当前文件目录下执行) npm config set registry https://registry.npm.taobao.org npm install 或者： npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm install*/var gulp = require('gulp');var debug = require('gulp-debug');var cleancss = require('gulp-clean-css'); //css压缩组件var cssversion = require('gulp-make-css-url-version'); //css资源添加版本号var uglify = require('gulp-uglify'); //js压缩组件var htmlmin = require('gulp-htmlmin'); //html压缩组件var htmlclean = require('gulp-htmlclean'); //html清理组件var assetRev = require('gulp-asset-rev'); //版本控制插件var runSequence = require('run-sequence'); //异步执行组件var changed = require('gulp-changed'); //文件更改校验组件var gulpif = require('gulp-if') //任务 帮助调用组件var plumber = require('gulp-plumber'); //容错组件（发生错误不跳出任务，并报出错误内容）var isScriptAll = true; //是否处理所有文件，(true|处理所有文件)(false|只处理有更改的文件)var isDebug = true; //是否调试显示 编译通过的文件// 压缩js文件gulp.task('compressJs', function () &#123; var option = &#123; // preserveComments: 'all',//保留所有注释 mangle: true, //类型：Boolean 默认：true 是否修改变量名 compress: true //类型：Boolean 默认：true 是否完全压缩 &#125; return gulp.src(['./_Web/**/*.js','!./_Web/**/*.min.js']) //排除的js .pipe(gulpif(!isScriptAll, changed('./_Web'))) .pipe(gulpif(isDebug,debug(&#123;title: 'Compress JS:'&#125;))) .pipe(plumber()) .pipe(uglify(option)) //调用压缩组件方法uglify(),对合并的文件进行压缩 .pipe(gulp.dest('./_Web')); //输出到目标目录&#125;);// 压缩css文件gulp.task('compressCss', function () &#123; return gulp.src('./_Web/**/*.css') .pipe(gulpif(!isScriptAll, changed('./_Web'))) .pipe(gulpif(isDebug,debug(&#123;title: 'Compress CSS:'&#125;))) .pipe(plumber()) .pipe(cleancss(&#123;rebase: false&#125;)) .pipe(gulp.dest('./_Web'));&#125;);// 压缩html文件gulp.task('compressHtml', function () &#123; var cleanOptions = &#123; protect: /&lt;\\!--%fooTemplate\\b.*?%--&gt;/g, //忽略处理 unprotect: /&lt;script [^&gt;]*\\btype=\"text\\/x-handlebars-template\"[\\s\\S]+?&lt;\\/script&gt;/ig //特殊处理 &#125; var minOption = &#123; collapseWhitespace: true, //压缩HTML collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked=\"true\"/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id=\"\" /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=\"text/javascript\" removeStyleLinkTypeAttributes: true,//删除&lt;style&gt;和&lt;link&gt;的type=\"text/css\" removeComments: true, //清除HTML注释 minifyJS: true, //压缩页面JS minifyCSS: true, //压缩页面CSS minifyURLs: true //替换页面URL &#125;; return gulp.src('./_Web/**/*.html') .pipe(gulpif(isDebug,debug(&#123;title: 'Compress HTML:'&#125;))) .pipe(plumber()) .pipe(htmlclean(cleanOptions)) .pipe(htmlmin(minOption)) .pipe(gulp.dest('./_Web'));&#125;);// 默认任务gulp.task('default', function () &#123; runSequence.options.ignoreUndefinedTasks = true; runSequence('compressHtml','compressCss','compressJs');&#125;); 这里注意 上面配置文件中出现的 地址需要自行替换 ,将./_web/ 替换为 ./你的工程上传目录/ ，这才算修改完毕了。请查看根目录下配置文件：_config.yml 中 public_dir 配置，我的如下_config.yml...public_dir: _Web... 执行准备工作都做好了，执行命令： 编译工程 hexo -g 执行 构建工具 gulp 或gulp default 上传工程 hexo -d","categories":[{"name":"前端","slug":"前端","permalink":"https://zhuzhuyule.com/categories/前端/"},{"name":"Hexo","slug":"前端/Hexo","permalink":"https://zhuzhuyule.com/categories/前端/Hexo/"}],"tags":[{"name":"Gulp","slug":"Gulp","permalink":"https://zhuzhuyule.com/tags/Gulp/"},{"name":"构建工具","slug":"构建工具","permalink":"https://zhuzhuyule.com/tags/构建工具/"},{"name":"Hexo优化系列","slug":"Hexo优化系列","permalink":"https://zhuzhuyule.com/tags/Hexo优化系列/"}]},{"title":"Linux的scp命令","slug":"Skill/Linux的scp命令","date":"2017-01-15T10:54:23.000Z","updated":"2017-12-28T07:28:09.288Z","comments":true,"path":"blog/Skill/Linux的scp命令.html","link":"","permalink":"https://zhuzhuyule.com/blog/Skill/Linux的scp命令.html","excerpt":"Linux之间复制 文件 和 目录 使用命令：scp，命令基本格式：scp [可选参数] file_source file_target","text":"Linux之间复制 文件 和 目录 使用命令：scp，命令基本格式：scp [可选参数] file_source file_target 介绍 linux 之间复制 文件 和 目录使用命令：scp 命令 命令基本格式：scp [可选参数] file_source file_target 复制文件命令模板1234scp local_file remote_username@remote_ip:remote_folder scp local_file remote_username@remote_ip:remote_filescp local_file remote_ip:remote_folderscp local_file remote_ip:remote_file 1指定了用户名，命令执行后需要再输入密码，仅指定了远程的目录（文件名不变）；2指定了用户名，命令执行后需要再输入密码，指定了远程的目录且指定了文件名；3 命令执行后需要输入用户名和密码，仅指定了远程的目录（文件名不变）；4 命令执行后需要输入用户名和密码，指定了远程的目录且指定了文件名； 样例1234scp ~/home/test.txt zhuzhutest@10.1.1.2:/home/scp ~/home/test.txt zhuzhutest@10.1.1.2:/home/change_name.txtscp ~/home/test.txt 10.1.1.2:/home/scp ~/home/test.txt 10.1.1.2:/home/change_name.txt 复制目录命令模板12scp -r local_folder remote_username@remote_ip:remote_folderscp -r local_folder remote_ip:remote_folder 1指定了用户名，命令执行后需要再输入密码； 2 命令执行后需要输入用户名和密码； 样例12scp -r ~/home/folder1 zhuzhutest@10.1.1.2:/home/scp -r ~/home/folder2 10.1.1.2:/home/ 将本机用户下~/home/folder1目录和~/home/folder2目录分别复制远程目标Linux。","categories":[{"name":"编程","slug":"编程","permalink":"https://zhuzhuyule.com/categories/编程/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://zhuzhuyule.com/tags/Linux命令/"},{"name":"Shell","slug":"Shell","permalink":"https://zhuzhuyule.com/tags/Shell/"}]},{"title":"HEXO下的Markdown语法(GFM)写博客","slug":"HEXO/HEXO下的Markdown语法(GFM)写博客","date":"2017-01-10T10:54:23.000Z","updated":"2017-11-30T02:07:57.287Z","comments":true,"path":"blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html","link":"","permalink":"https://zhuzhuyule.com/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html","excerpt":"Markdown 是一种轻量级的「标记语言」，优点在于 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。","text":"Markdown 是一种轻量级的「标记语言」，优点在于 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 并且具有以下特点： 自动生成目录 代码块高亮 引用展示 表格插入 图片插入 强调显示 列表显示 自动URL链接 Hexo下使用的MarkDown为Github的GFM，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准 的MarkDown稍有不同，使用过程中需要注意一些。 语法简明概述 分段 两个回车 换行 两个空格 + 回车 标题 # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题 强调 **文字** ， __文字__ ， _文字_ ， *文字* ， ~~文字~~ 引用 &gt; 注意后面紧跟个空格 表格 - 和 | 分割行和列 ， : 控制对其方式 代码块 四个空格 开头或， 使用``` 代码内容 ``` 链接 [文字](链接地址) 图片 ![图片说明](图片地址) ，地址可以是本地路劲，也可以是网络地址 列表 * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格 标题12345678910# 欢迎使用Markdown编辑器写博客 //一级标题 对应 &lt;h1&gt; &lt;/h1&gt;## 标题输入 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;### 三级标题 //三级标题 对应 &lt;h3&gt; &lt;/h3&gt;#### 四级标题 //四级标题 对应 &lt;h4&gt; &lt;/h4&gt;##### 五级标题 //五级标题 对应 &lt;h5&gt; &lt;/h5&gt;###### 六级标题 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt;####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行）二级标题 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;---- //这里添加四个'－' （减号） 这里不做展示了，影响目录的展示。 内容强调加粗、斜体123字体 **加粗** 显示字体 *斜体* 显示字体 ***加粗并斜体*** 显示 字体 加粗 显示字体 斜体 显示字体 加粗并斜体 显示 1234字体 __加粗__ 显示字体 _斜体_ 显示字体 ___加粗并斜体___ 显示组合 *__加粗并斜体__* 显示 字体 加粗 显示字体 斜体 显示字体 加粗并斜体 显示组合 加粗并斜体 显示 删除线1这样来 ~~删除一段文本~~ 这样来 删除一段文本 高亮12使用&lt;code&gt;\\`&lt;/code&gt;来强调字符 //想打出 ` (反引号)需要转义的，加&lt;code&gt;&lt;/code&gt;标签强调比如`突出背景色`来显示强调效果 使用`来强调字符比如突出背景色来显示强调效果 引用显示引用过程中任然支持Markdown语法！ 标准使用12345678&gt; 每行开始都使用 '&gt;'；&gt; 引用**开始**；&gt; 引用**换行**；&gt; 引用**结束**。&gt; 还在引用中！两个回车结束引用！ 每行开始都使用 ‘&gt;’；引用开始；引用换行；引用结束。 还在引用中！ 两个回车结束引用！ 省略使用123456&gt; 仅第一行加应用；引用**开始**；引用**换行**；引用**结束**；两个回车结束引用,不在引用范围内了！ 仅第一行加应用；引用开始；引用换行；引用结束； 两个回车 结束引用,不在引用范围内了！ 嵌套使用123456789101112131415&gt; 动物&gt;&gt; 水生动物&gt;&gt; 陆生动物&gt;&gt;&gt; 猴子&gt;&gt;&gt; 人&gt;&gt;&gt;&gt; 程序猿&gt;&gt;&gt;&gt; 攻城狮&gt;&gt;产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 //这里需要注意，没有空行间隔，忽略降级引用标记&gt;&gt; 两栖类动物&gt;&gt;&gt; 大鳄鱼唐老鸭两个回车结束引用,不在引用范围内了！ 动物 水生动物陆生动物 猴子人 程序猿攻城狮产品狗 这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 这里需要注意，没有空行间隔，忽略降级引用标记 两栖类动物 大鳄鱼唐老鸭 两个回车 结束引用,不在引用范围内了！ 表格 表格语法：12345列1 | 列2 | 列3 ----- | --- | ---- 第1行 | 12 | 13 第2行 | 22 | 23 第3行 | 32 | 33 列1 列2 列3 第1行 12 13 第2行 22 23 第3行 32 33 可以使用冒号来定义对齐方式：1234| 左对齐 | 右对齐 | 居中 || :-------- | -------:| :--: || Computer | 5000 元 | 1台 || Phone | 1999 元 | 1部 | 左对齐 右对齐 居中 Computer 5000 元 1台 Phone 1999 元 1部 代码块代码块语法遵循标准 markdown 代码，使用 ``` 开始， ``` 结束，例如：12345```Python#!/usr/bin/env python# -*- coding: utf-8 -*-print 'Hello World!``` 以上代码框及代码输入内容123#!/usr/bin/env python# -*- coding: utf-8 -*-print 'Hello World!' 特别提示 如何在代码块中打出 ```12345```````复制到你的`markdown`中看看去吧！``````` 实际上是使用 4个` 包含 3个` 就可以了，想表示更多，最外层+1就好了。`````````````` 链接插入123[首页](https://zhuzhuyule.com)[我的信息](/about/)[纪念册](https://love.zhuzhuyule.com/) 首页 我的信息 纪念册 图片插入12![我的头像](https://zhuzhuyule.com/images/avatar.png)![我的头像](/images/avatar.png) 列表无序列表123456789* `*`列表展示* `*`列表展示 * `*`列表展示+ `+`列表展示+ `+`列表展示 + `+`列表展示- `-`列表展示- `-`列表展示 - `-`列表展示 *列表展示 *列表展示 *列表展示 +列表展示 +列表展示 +列表展示 -列表展示 -列表展示 -列表展示 有序列表123456789101112这种方式不用手动设置序号，自动生成列表序列1. **我是一级序列** 1. **我是一级序列** 1. **我是一级序列** 1. *我是二级序列* 1. *我是二级序列* 1. *我是二级序列* 1. **我是一级序列** 1. **我是一级序列** 1. *我是二级序列* 1. *我是二级序列* 1. 还是二级序列，没有三级序列 这种方式不用手动设置序号，自动生成列表序列 我是一级序列 我是一级序列 我是一级序列 我是二级序列 多于一级序列一个空格 我是二级序列 多于一级序列一个空格 我是二级序列 多于一级序列一个空格 我是一级序列 我是一级序列 我是二级序列 多于一级序列一个空格 我是二级序列 多于一级序列一个空格 还是二级序列，没有三级序列 虽然多于二级序列一个空格，但是任然是二级序列 链接自动检测123首页:https://zhuzhuyule.com我的信息:https://zhuzhuyule.com/about/纪念册:https://love.zhuzhuyule.com/ 首页:https://zhuzhuyule.com 我的信息:https://zhuzhuyule.com/about/ 纪念册:https://love.zhuzhuyule.com/","categories":[{"name":"前端","slug":"前端","permalink":"https://zhuzhuyule.com/categories/前端/"},{"name":"Hexo","slug":"前端/Hexo","permalink":"https://zhuzhuyule.com/categories/前端/Hexo/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://zhuzhuyule.com/tags/Markdown/"},{"name":"语法","slug":"语法","permalink":"https://zhuzhuyule.com/tags/语法/"}]}]}